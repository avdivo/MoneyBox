<?php

//Проверяем на вход с переданными параметрами
//номер копилки -> сумма со знаком, обозначающим запись или изъятие из копилки этой суммы
if (isset($_POST["transfer"]))
{
    //Преобразуем полученную JSON строку в массив
    $transfer = json_decode($_POST["transfer"], true); 
    //var_dump($my_new_array); 

    $debt =  $transfer['dolg']; //Если перевод делается в долг переменная будет True
    unset ($transfer['dolg']); //Удаляем элемент масива с долгом, оставляем только операции над копилками

    //Проверяем, во всех ли копилках хватает денег чтобы изъять их
    //Запрос к БД на получение сумм в копилках 
    $query ="SELECT `id`, `summa` FROM `box` WHERE `id`!= '1'";

    $result = mysqli_query($link, $query); 
    if (!$result) die ("Не удалось получить суммы в копилках.");
    
    $arraySumBox = []; //Собираем в массив пары Номер копилки -> Сумма в копилке
    
    //Если копилок нет, пропускаем все действия
    if ($result) {
        //var_dump($row); 
        while ($row = $result->fetch_assoc()) {       //Выбираем массив ключ -> значение, каждая сумма в копилке
            $arraySumBox += [$row["id"] => $row["summa"]];    //Заносим в массив 
        }

        //Перебираем массив с переданными значениями (номер копилки -> сумма со знаком)
        //Находим номер копилки которая учавствует в операциях
        //находим эту копилку (тот же ключ) в arraySumBox (с суммами в копилках) и прибавляем значение операции
        //поскольку значения со знаком бкдут проискохить и отнимания
        //Если результат хоть в одном случае отрицательный (не хватает денег в копилке), то все операции отменяются
        //Бюджет не проверяем - копилка с номером 1
            //Источник или приемник может быть один, а обратных один или несколько
            //Значит, может быть одна копилка со знаком -, и одна или несколько со знаком + или
            //может быть одна копилка со знаком +, и одна или несколько со знаком -
            //В этом же цикле находим ту самую одну копилку, если их всего 2, то не важно какая из них будет найдена
        $howMinus = 0; //Сколько минусов
        $howPlus = 0; //Сколько минусов
        $lastMinus; //Последний номер копилки с минусом
        $lastPlus; //Последний номер копилки с плюсом
        $er = 1; //Результат операции, отрицательное значение укажет на ошибку 

        foreach ($transfer as $key => $value) {
            if ($key != '1') { //Бюджет не проверяем
                if (($er = $arraySumBox[$key]+$value) < 0) break; //Отрицательное значение - это ошибка
            }
            if ($value < 0){
                $howMinus++;
                $lastMinus = $key;
            }
            if ($value > 0){
                $howPlus++;
                $lastPlus = $key;
            }
        }

        //Если у $er положительное значение, значит можно совершать операции
        if ($er >= 0){
            //Та копилка знак которой уникальный учавствует во всех операциях
            //Или из остальных поступает ей, или из нее в остальные
            //Назначаем такую копилку
            if ($howMinus == 1) {
                //Отрицательное значение одно, значит источник уникальный из копилки отнимается
                //Источник не меняется, это одна копилка ее номер в source, а так же в unique
                //чтоб при переборе копилок себя пропустить, не совершать операцию перевода с собой
                $source = $unique = $lastMinus; 
                $noUnique = &$receiver; //Приемники разные, переменная receiver будкт меняться через ссылку noUnique

            }  else {
                //Положительное значение одно, значит приемник уникальный в копилку поступает
                //Приемник не меняется, это одна копилка ее номер в receiver, а так же в unique
                //чтоб при переборе копилок себя пропустить, не совершать операцию перевода с собой
                $receiver = $unique = $lastPlus; 
                $noUnique = &$source; //Источники разные, переменная source будкт меняться через ссылку noUnique
            }
    
            //Для записи операций в БД нужно создать объект который это выполнит
            //Подготовка транзакции
            $trans = new Transactions(); //Создаем объект транзакций

            //$source - источник, $receiver - приемник, $summa - сумма, $debt - индикатор в долг или нет
            //Источник или приемник будет меняться, но менять будем не саму переменную, а ее через ссылку
            //Вторая из переменных уже присвоена. Переменная $debt тоже задана и не меняется
            foreach ($transfer as $noUnique => $value) { 
                if ($noUnique != $unique) {//Не меняется источник или приемник указанный в unique, пропускаем эту копилку
                    $summa = abs($value); //У суммы убираем знак
                    //$noUnique это ссылка на receiver или source, она присвоена, остальные тоже

                    $trans->summaTrans = $summa; //Сумма перевода
                    $trans->sourceTrans = $source; //Источник перевода
                    $trans->receiverTrans = $receiver; //Приемник перевода
                    $trans->additionTrans = ''; //Для долга он создастся автоматически, при остальных операциях не нужен
                    //Выясняем код операции:
                    //1. Взнос - источник Бюджет, 2. Перевод - оба Копилки, 3. Изъятие - приемник Бюджет, 4. Долг - $debt = true
                    $trans->eventTrans = '2';
                    if ($source == '1') $trans->eventTrans = '1';
                    if ($receiver == '1') $trans->eventTrans = '3';

                    //Подготовка запросов к БД
                    if ($trans->boxChangeTrans() == '-1') die ('Ошибка при изменении сумм в копилках.'); //Меняем суммы в копилках. Выходим с ошибкой если не хватает денег
                    //Если это перевод в долг то делаем долговую запись
                    if ($debt) {
                        $trans->eventTrans = '4'; //Код операции - Долг
                        if ($trans->debtChangeTrans() == '-1')  die ('Ошибка при оформлении долга.'); //Делаем долговую запись. Выходим если ошибка
                    }

                    //Выполняем транзакцию с записью истории (true). Выходим если ошибка
                    if ($trans->saveTrans(true) == '-1') die ('Ошибка выполнения записи в БД.');
                    
                }

            }

        }

    }    

    return;
}

?>